<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Create Attestation - attest.ink</title>
    <meta name="description" content="Create a verifiable attestation for your AI-generated content">
    <link rel="icon" type="image/svg+xml" href="/assets/logo/favicon.svg">
    <link rel="icon" type="image/x-icon" href="/assets/favicon.ico">
    <link rel="manifest" href="/assets/site.webmanifest">
    <meta name="theme-color" content="#111827">
    <link rel="stylesheet" href="/static/style.css">
    <link rel="stylesheet" href="/static/badge-styles.css">
    <script src="/static/ai-models.js?v=2"></script>
    <script>
        // Prevent theme flicker by setting theme before render
        (function() {
            const saved = localStorage.getItem('theme');
            let theme = 'light';
            if (saved) {
                theme = saved;
            } else if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                theme = 'dark';
            } else {
                const hour = new Date().getHours();
                if (hour >= 18 || hour < 6) {
                    theme = 'dark';
                }
            }
            document.documentElement.setAttribute('data-theme', theme);
        })();
    </script>
</head>
<body>
    <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme">D</button>
    <div class="container">
        <nav>
            <div class="nav-inner">
                <a href="/" class="logo">
                    <img src="/assets/logo/circular-2-ai.svg" alt="attest.ink logo">
                    <span>attest.ink</span>
                </a>
                <ul>
                    <li><a href="/create/" class="active">Create</a></li>
                    <li><a href="/verify/">Verify</a></li>
                    <li class="dropdown">
                        <span class="dropdown-toggle">More</span>
                        <div class="dropdown-menu">
                            <a href="/protocol/">Protocol</a>
                            <a href="/showcase/">Badges</a>
                            <a href="/examples/">Examples</a>
                            <a href="/developers/">Developer Docs</a>
                            <a href="/faq.html">FAQ</a>
                            <a href="https://github.com/statusdothealth/attest.ink" target="_blank">GitHub</a>
                        </div>
                    </li>
                </ul>
            </div>
        </nav>

        <main>
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h1 style="margin: 0;">Create AI Attestation</h1>
                <button type="button" class="btn btn-secondary" id="reset-form">Reset Form</button>
            </div>

            <form id="attestation-form">
                <div class="form-group">
                    <label>Import Options</label>
                    <div style="margin-bottom: 20px;">
                        <label style="font-weight: normal; display: block; margin-bottom: 10px; padding: 20px; background: var(--bg-panel); border: 2px dashed var(--border-color); border-radius: 8px; cursor: pointer; text-align: center;">
                            <input type="file" id="import-file" accept=".json,.txt,.md,.html,.pdf,.tex,.js,.py,.jpg,.jpeg,.png,.gif,.mp3,.mp4" style="display: none;">
                            <span id="import-label" style="display: flex; flex-direction: column; align-items: center; gap: 12px;">
                                <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" style="opacity: 0.6;">
                                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                                    <polyline points="7 10 12 15 17 10"></polyline>
                                    <line x1="12" y1="15" x2="12" y2="3"></line>
                                </svg>
                                <span style="font-size: 16px; font-weight: 500;">Click to upload file or drag and drop</span>
                                <span style="font-size: 14px; color: var(--text-secondary);">Upload content, attestation JSON, or paste URL below</span>
                            </span>
                        </label>
                        
                        <div class="import-url-container" style="margin-top: 10px; display: flex; gap: 10px; align-items: center;">
                            <input type="url" id="import-url" placeholder="Or paste URL to import content..." style="flex: 1;">
                            <button type="button" id="import-url-btn" class="btn btn-secondary">Import URL</button>
                        </div>
                        
                        <p style="font-size: 0.9em; color: var(--text-secondary); margin: 10px 0; text-align: center;">
                            — or manually enter the details below —
                        </p>
                    </div>
                </div>

                <div class="form-group">
                    <label for="content-name">Content Name <span style="color: var(--color-danger);">*</span></label>
                    <input type="text" id="content-name" name="content_name" placeholder="e.g., Blog Post: AI in Healthcare" required>
                    <p style="font-size: 0.9em; color: var(--text-secondary); margin: 5px 0;">A descriptive name for your content</p>
                </div>

                <div class="form-group">
                    <label for="content">Content (Optional)</label>
                    <textarea id="content" name="content" rows="10" placeholder="Paste your content here (optional)"></textarea>
                    <p style="font-size: 0.9em; color: var(--text-secondary); margin: 5px 0;">Paste content to generate hash. If omitted, only the content name will be attested.</p>
                </div>

                <div class="form-group">
                    <label for="document-type">Document Type</label>
                    <select id="document-type" name="document_type" required>
                        <option value="">Select type...</option>
                        <option value="text">Plain Text</option>
                        <option value="markdown">Markdown</option>
                        <option value="html">HTML</option>
                        <option value="website">Website</option>
                        <option value="pdf">PDF</option>
                        <option value="academic_paper">Academic Paper</option>
                        <option value="latex">LaTeX</option>
                        <option value="code">Source Code</option>
                        <option value="image">Image</option>
                        <option value="audio">Audio</option>
                        <option value="video">Video</option>
                        <option value="other">Other (specify)</option>
                    </select>
                    <input type="text" id="document-type-other" name="document_type_other" placeholder="Specify document type..." style="display: none; margin-top: 10px;">
                </div>

                <div class="form-group">
                    <label for="model">AI Model</label>
                    <select id="model" name="model" required>
                        <option value="">Select model...</option>
                    </select>
                    <input type="text" id="model-other" name="model_other" placeholder="Specify model name..." style="display: none; margin-top: 10px;">
                </div>

                <div class="form-group">
                    <label for="role">AI Role</label>
                    <select id="role" name="role" required>
                        <option value="generated">AI Generated (100% AI)</option>
                        <option value="assisted">AI Assisted (Human + AI collaboration)</option>
                        <option value="edited">AI Edited (Human created, AI refined)</option>
                        <option value="other">Other (specify)</option>
                    </select>
                    <input type="text" id="role-other" name="role_other" placeholder="Specify AI role..." style="display: none; margin-top: 10px;">
                </div>

                <div class="form-group">
                    <label for="prompt">Prompt (Optional)</label>
                    <textarea id="prompt" name="prompt" rows="4" placeholder="The prompt or instructions given to the AI"></textarea>
                    <label style="font-weight: normal; margin-top: 5px;">
                        <input type="checkbox" id="prompt-private" name="prompt_private" checked> 
                        Keep prompt private (only hash will be included)
                    </label>
                </div>

                <div class="form-group">
                    <label for="author">Author/Creator (Optional)</label>
                    <input type="text" id="author" name="author" placeholder="Your name or identifier">
                </div>

                <div class="form-group">
                    <label for="badge-style">Badge Style</label>
                    <select id="badge-style" name="badge_style">
                        <option value="default">Default (Standard)</option>
                        <option value="glass">Glass Effect</option>
                        <option value="glass-minimal">Minimalist</option>
                        <option value="terminal">Terminal Style</option>
                        <option value="neon">Neon Glow</option>
                        <option value="rainbow">Rainbow</option>
                        <option value="matrix">Matrix</option>
                        <option value="holographic">Holographic</option>
                        <option value="latex">LaTeX (Academic)</option>
                    </select>
                    <div id="badge-style-preview" style="margin-top: 10px; padding: 10px; background: var(--bg-panel); border: 2px solid var(--border-color); text-align: center;">
                        <span class="ai-badge">Preview</span>
                    </div>
                </div>

                <div class="form-group">
                    <label>Digital Signature (Optional)</label>
                    <div class="section" style="padding: 1rem; margin-bottom: 1rem;">
                        <label style="font-weight: normal; display: block; margin-bottom: 0.5rem;">
                            <input type="radio" name="sign-method" value="local" checked> 
                            Local Signature (No wallet needed) - Recommended
                        </label>
                        <label style="font-weight: normal; display: block; margin-bottom: 0.5rem;">
                            <input type="radio" name="sign-method" value="wallet"> 
                            Ethereum Wallet (MetaMask, etc.)
                        </label>
                        <label style="font-weight: normal; display: block; margin-bottom: 0.5rem;">
                            <input type="radio" name="sign-method" value="hmac"> 
                            HMAC-SHA256 Signature (Server-side key)
                        </label>
                        <label style="font-weight: normal; display: block;">
                            <input type="radio" name="sign-method" value="none"> 
                            No Signature
                        </label>
                    </div>
                    <div id="hmac-section" style="display: none;">
                        <div style="padding: 15px; background: var(--bg-panel); border: 1px solid var(--border-color); border-radius: 8px; margin-top: 10px;">
                            <p style="margin-bottom: 10px;">HMAC-SHA256 signatures require a signing key. This is typically used for server-side attestations.</p>
                            <label for="signer-name" style="display: block; margin-bottom: 5px;">Signer Name:</label>
                            <input type="text" id="signer-name" placeholder="e.g., Austin Harshberger" style="width: 100%; margin-bottom: 10px;">
                            <label for="signer-id" style="display: block; margin-bottom: 5px;">Signer ID (optional):</label>
                            <input type="text" id="signer-id" placeholder="e.g., 97115104" style="width: 100%; margin-bottom: 10px;">
                            <p style="font-size: 0.9em; color: var(--text-muted); margin-bottom: 0;">Note: The actual signing will need to be done server-side with your private key.</p>
                        </div>
                    </div>
                    <div id="wallet-section">
                        <div style="padding: 15px; background: var(--bg-panel); border: 1px solid var(--border-color); border-radius: 8px;">
                            <button type="button" id="connect-wallet" class="btn btn-secondary" style="width: 100%;">
                                <span id="wallet-button-text">Connect Ethereum Wallet</span>
                                <span id="wallet-spinner" style="display: none; margin-left: 10px;">⏳</span>
                            </button>
                            <div id="wallet-status" style="margin-top: 10px; padding: 10px; background: var(--bg-surface); border-radius: 4px; text-align: center; color: var(--text-secondary); display: none;"></div>
                            <div style="margin-top: 10px; padding: 10px; background: var(--bg-surface); border: 1px solid var(--border-color); border-radius: 4px; font-size: 0.85em; color: var(--text-secondary);">
                                <strong>Note:</strong> MetaMask will open in a new window/tab when signing. This is a security feature and cannot be changed. Consider using "Local Signature" for a smoother experience.
                            </div>
                        </div>
                    </div>
                    <div id="local-section" style="display: none;">
                        <input type="password" id="signing-password" placeholder="Enter a password for signing" style="margin-bottom: 10px;">
                        <p style="font-size: 0.9em; color: var(--text-secondary); margin: 5px 0;">Password is used to generate a unique signature</p>
                    </div>
                </div>

                <div style="margin-top: 30px;">
                    <button type="submit" class="btn">Generate Attestation</button>
                </div>
            </form>

        </main>

    </div>

    <script src="/static/badge-renderer.js"></script>
    <script>
        // Populate AI models dropdown
        document.addEventListener('DOMContentLoaded', function() {
            const modelSelect = document.getElementById('model');
            
            // Add models grouped by provider - Anthropic first, then alphabetically
            const providerOrder = ['anthropic'];
            
            // Add remaining providers alphabetically
            Object.keys(AI_MODELS).forEach(key => {
                if (!providerOrder.includes(key)) {
                    providerOrder.push(key);
                }
            });
            providerOrder.sort((a, b) => {
                if (a === 'anthropic') return -1;
                if (b === 'anthropic') return 1;
                return a.localeCompare(b);
            });
            
            // Add models by provider
            providerOrder.forEach(providerId => {
                const provider = AI_MODELS[providerId];
                if (provider) {
                    const optgroup = document.createElement('optgroup');
                    optgroup.label = provider.name;
                    
                    provider.models.forEach(model => {
                        const option = document.createElement('option');
                        option.value = model.id;
                        option.textContent = model.name;
                        optgroup.appendChild(option);
                    });
                    
                    modelSelect.appendChild(optgroup);
                }
            });
            
            // Add "Other" option at the end
            const otherOption = document.createElement('option');
            otherOption.value = 'other';
            otherOption.textContent = 'Other (specify)';
            modelSelect.appendChild(otherOption);
            
            // Restore saved form data
            restoreFormData();
            
            // Save form data on change
            const form = document.getElementById('attestation-form');
            const inputs = form.querySelectorAll('input, select, textarea');
            inputs.forEach(input => {
                input.addEventListener('change', saveFormData);
                input.addEventListener('input', saveFormData);
            });
        });
        
        // Track if form has unsaved changes
        let formHasChanges = false;
        
        // Save form data to localStorage
        function saveFormData() {
            const formData = {
                contentName: document.getElementById('content-name').value,
                content: document.getElementById('content').value,
                documentType: document.getElementById('document-type').value,
                model: document.getElementById('model').value,
                modelOther: document.getElementById('model-other').value,
                role: document.getElementById('role').value,
                roleOther: document.getElementById('role-other').value,
                author: document.getElementById('author').value,
                prompt: document.getElementById('prompt').value,
                promptPrivate: document.getElementById('prompt-private').checked,
                badgeStyle: document.getElementById('badge-style').value
            };
            localStorage.setItem('attestFormData', JSON.stringify(formData));
            
            // Mark form as having changes if any field has content
            formHasChanges = formData.contentName || formData.content || formData.author || formData.prompt;
        }
        
        // Restore form data from localStorage
        function restoreFormData() {
            const savedData = localStorage.getItem('attestFormData');
            if (savedData) {
                try {
                    const formData = JSON.parse(savedData);
                    
                    // Restore values
                    if (formData.contentName) document.getElementById('content-name').value = formData.contentName;
                    if (formData.content) document.getElementById('content').value = formData.content;
                    if (formData.documentType) document.getElementById('document-type').value = formData.documentType;
                    if (formData.model) {
                        document.getElementById('model').value = formData.model;
                        document.getElementById('model').dispatchEvent(new Event('change'));
                    }
                    if (formData.modelOther) document.getElementById('model-other').value = formData.modelOther;
                    if (formData.role) {
                        document.getElementById('role').value = formData.role;
                        document.getElementById('role').dispatchEvent(new Event('change'));
                    }
                    if (formData.roleOther) document.getElementById('role-other').value = formData.roleOther;
                    if (formData.author) document.getElementById('author').value = formData.author;
                    if (formData.prompt) document.getElementById('prompt').value = formData.prompt;
                    if (formData.promptPrivate !== undefined) document.getElementById('prompt-private').checked = formData.promptPrivate;
                    if (formData.badgeStyle) document.getElementById('badge-style').value = formData.badgeStyle;
                    
                    // Update badge preview
                    updateBadgePreview();
                } catch (e) {
                    console.error('Error restoring form data:', e);
                }
            }
        }
        
        // Add beforeunload warning to prevent accidental data loss
        window.addEventListener('beforeunload', function(e) {
            // Only show warning if form has changes and we're not on the result section
            if (formHasChanges && document.getElementById('attestation-form').style.display !== 'none') {
                const message = 'You have unsaved changes in your attestation form. Are you sure you want to leave?';
                e.preventDefault();
                e.returnValue = message; // Chrome requires returnValue to be set
                return message; // Some browsers need the return value
            }
        });
    </script>
    <script>
        // Import handling
        const importFileInput = document.getElementById('import-file');
        const importLabel = document.getElementById('import-label');
        const importUrlInput = document.getElementById('import-url');
        const importUrlBtn = document.getElementById('import-url-btn');
        const contentTextarea = document.getElementById('content');
        const contentNameInput = document.getElementById('content-name');
        const documentTypeSelect = document.getElementById('document-type');
        
        // Function to populate form fields from attestation JSON
        function populateFromAttestation(attestation) {
            // Set content name
            if (attestation.content_name) {
                contentNameInput.value = attestation.content_name;
            }
            
            // Set document type
            if (attestation.document_type) {
                document.getElementById('document-type').value = attestation.document_type;
                document.getElementById('document-type').dispatchEvent(new Event('change'));
            }
            
            // Set model
            if (attestation.model) {
                document.getElementById('model').value = attestation.model;
                document.getElementById('model').dispatchEvent(new Event('change'));
            }
            
            // Set role
            if (attestation.role) {
                const roleSelect = document.getElementById('role');
                // Check if it's a standard role
                const standardRoles = ['generated', 'assisted', 'edited'];
                if (standardRoles.includes(attestation.role)) {
                    roleSelect.value = attestation.role;
                } else {
                    // Custom role
                    roleSelect.value = 'other';
                    roleSelect.dispatchEvent(new Event('change'));
                    setTimeout(() => {
                        document.getElementById('role-other').value = attestation.role;
                    }, 100);
                }
            }
            
            // Set author
            if (attestation.author) {
                document.getElementById('author').value = attestation.author;
            }
            
            // Set prompt
            if (attestation.prompt) {
                document.getElementById('prompt').value = attestation.prompt;
                document.getElementById('prompt-private').checked = false;
            } else if (attestation.prompt_hash) {
                document.getElementById('prompt').value = '[Prompt was kept private - hash: ' + attestation.prompt_hash + ']';
                document.getElementById('prompt-private').checked = true;
            }
            
            // Update badge preview
            updateBadgePreview();
            
            // Mark form as having changes after import
            formHasChanges = true;
            
            alert('Attestation data imported successfully! Review and modify as needed.');
        }
        
        importFileInput.addEventListener('change', async function(e) {
            const file = e.target.files[0];
            if (file) {
                importLabel.innerHTML = `
                    <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" style="opacity: 0.6">
                        <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                        <polyline points="14 2 14 8 20 8"></polyline>
                        <line x1="16" y1="13" x2="8" y2="13"></line>
                        <line x1="16" y1="17" x2="8" y2="17"></line>
                        <polyline points="10 9 9 9 8 9"></polyline>
                    </svg>
                    <span style="font-size: 16px; font-weight: 500;">${file.name}</span>
                    <span style="font-size: 14px; color: var(--text-secondary);">File loaded</span>
                `;
                
                // Auto-fill content name from filename if empty
                if (!contentNameInput.value) {
                    const nameWithoutExt = file.name.replace(/\.[^/.]+$/, "");
                    contentNameInput.value = nameWithoutExt;
                }
                
                // Auto-detect document type based on file extension
                const extension = file.name.toLowerCase().split('.').pop();
                const documentTypeSelect = document.getElementById('document-type');
                const badgeStyleSelect = document.getElementById('badge-style');
                
                const extensionToType = {
                    'txt': 'text',
                    'md': 'markdown',
                    'html': 'html',
                    'htm': 'html',
                    'pdf': 'pdf',
                    'tex': 'latex',
                    'js': 'code',
                    'py': 'code',
                    'java': 'code',
                    'cpp': 'code',
                    'c': 'code',
                    'cs': 'code',
                    'php': 'code',
                    'rb': 'code',
                    'go': 'code',
                    'rs': 'code',
                    'json': 'code',
                    'xml': 'code',
                    'yaml': 'code',
                    'yml': 'code',
                    'jpg': 'image',
                    'jpeg': 'image',
                    'png': 'image',
                    'gif': 'image',
                    'bmp': 'image',
                    'svg': 'image',
                    'webp': 'image',
                    'mp3': 'audio',
                    'wav': 'audio',
                    'ogg': 'audio',
                    'm4a': 'audio',
                    'flac': 'audio',
                    'mp4': 'video',
                    'avi': 'video',
                    'mov': 'video',
                    'wmv': 'video',
                    'mkv': 'video',
                    'webm': 'video'
                };
                
                const detectedType = extensionToType[extension];
                if (detectedType) {
                    documentTypeSelect.value = detectedType;
                    // Trigger change event to handle "other" input visibility
                    documentTypeSelect.dispatchEvent(new Event('change'));
                    
                    // Auto-select LaTeX badge style for .tex files
                    if (extension === 'tex') {
                        badgeStyleSelect.value = 'latex';
                        updateBadgePreview();
                    }
                }
                
                // Handle JSON attestation files specially
                if (file.name.endsWith('.json')) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        try {
                            const data = JSON.parse(e.target.result);
                            // Check if it's an attestation JSON
                            if (data.version && data.model && (data.content_hash || data.content_name)) {
                                populateFromAttestation(data);
                            } else {
                                // Just regular JSON content
                                contentTextarea.value = e.target.result;
                                formHasChanges = true;
                            }
                        } catch (err) {
                            // Not valid JSON, treat as text
                            contentTextarea.value = e.target.result;
                            formHasChanges = true;
                        }
                    };
                    reader.readAsText(file);
                } else if (file.type.startsWith('text/') || 
                    file.name.endsWith('.txt') || 
                    file.name.endsWith('.md') || 
                    file.name.endsWith('.tex') ||
                    file.name.endsWith('.js') ||
                    file.name.endsWith('.py')) {
                    // Read other text files
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        contentTextarea.value = e.target.result;
                        formHasChanges = true;
                    };
                    reader.readAsText(file);
                }
            }
        });
        
        // Drag and drop for import
        const dropZone = importFileInput.parentElement;
        
        dropZone.addEventListener('dragover', function(e) {
            e.preventDefault();
            dropZone.style.background = 'var(--color-primary-light)';
        });
        
        dropZone.addEventListener('dragleave', function(e) {
            e.preventDefault();
            dropZone.style.background = 'var(--bg-panel)';
        });
        
        dropZone.addEventListener('drop', function(e) {
            e.preventDefault();
            dropZone.style.background = 'var(--bg-panel)';
            
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                importFileInput.files = files;
                const event = new Event('change', { bubbles: true });
                importFileInput.dispatchEvent(event);
            }
        });
        
        // URL import functionality
        importUrlBtn.addEventListener('click', async function() {
            const url = importUrlInput.value.trim();
            if (!url) {
                alert('Please enter a URL');
                return;
            }
            
            try {
                importUrlBtn.textContent = 'Loading...';
                importUrlBtn.disabled = true;
                
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error('Failed to fetch content');
                }
                
                const contentType = response.headers.get('content-type');
                const text = await response.text();
                
                // Try to parse as JSON first
                if (contentType && contentType.includes('application/json')) {
                    try {
                        const data = JSON.parse(text);
                        if (data.version && data.model && (data.content_hash || data.content_name)) {
                            populateFromAttestation(data);
                            importUrlInput.value = '';
                            return;
                        }
                    } catch (e) {
                        // Not attestation JSON, treat as content
                    }
                }
                
                // Use as content
                contentTextarea.value = text;
                formHasChanges = true;
                
                // Try to extract filename from URL
                const urlPath = new URL(url).pathname;
                const filename = urlPath.split('/').pop() || 'imported-content';
                if (!contentNameInput.value) {
                    contentNameInput.value = filename.replace(/\.[^/.]+$/, "");
                }
                
                // Auto-detect type from URL extension
                const extension = filename.toLowerCase().split('.').pop();
                const extensionToType = {
                    'txt': 'text',
                    'md': 'markdown',
                    'html': 'html',
                    'json': 'code',
                    'js': 'code',
                    'py': 'code',
                    'tex': 'latex'
                };
                
                const detectedType = extensionToType[extension];
                if (detectedType) {
                    document.getElementById('document-type').value = detectedType;
                    document.getElementById('document-type').dispatchEvent(new Event('change'));
                }
                
                importUrlInput.value = '';
                importLabel.innerHTML = `
                    <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" style="opacity: 0.6">
                        <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path>
                        <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>
                    </svg>
                    <span style="font-size: 16px; font-weight: 500;">Content imported from URL</span>
                    <span style="font-size: 14px; color: var(--text-secondary);">${url}</span>
                `;
                
            } catch (error) {
                console.error('Import error:', error);
                alert('Failed to import from URL. Make sure the URL is accessible and CORS-enabled.');
            } finally {
                importUrlBtn.textContent = 'Import URL';
                importUrlBtn.disabled = false;
            }
        });
        
        // Auto-detect content type when URL is entered in content field
        contentTextarea.addEventListener('input', function() {
            const content = contentTextarea.value.trim();
            // Check if the content is a URL
            const urlPattern = /^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_\+.~#?&//=]*)$/;
            
            if (urlPattern.test(content) && documentTypeSelect.value === '') {
                // Auto-select "website" as content type
                documentTypeSelect.value = 'website';
                documentTypeSelect.dispatchEvent(new Event('change'));
            }
        });
        
        // Handle custom selections
        document.getElementById('document-type').addEventListener('change', function(e) {
            const otherInput = document.getElementById('document-type-other');
            otherInput.style.display = e.target.value === 'other' ? 'block' : 'none';
            if (e.target.value === 'other') {
                otherInput.required = true;
            } else {
                otherInput.required = false;
                otherInput.value = '';
            }
        });

        // Badge style preview
        const badgeStyleSelect = document.getElementById('badge-style');
        const badgePreview = document.getElementById('badge-style-preview');
        
        function updateBadgePreview() {
            const style = badgeStyleSelect.value;
            const modelSelect = document.getElementById('model');
            const roleSelect = document.getElementById('role');
            const modelId = modelSelect.value || 'gpt-4';
            const role = roleSelect.value || 'generated';
            
            let badgeHtml = '';
            if (style === 'default') {
                // For default, try to use AttestInk if available, otherwise fallback to a simple badge
                if (window.AttestInk && modelId && modelId !== 'other') {
                    badgeHtml = window.AttestInk.createBadgeSVG(modelId, role);
                } else {
                    // Fallback badge for when AttestInk isn't loaded or model is custom
                    const modelName = modelId === 'other' ? 'AI' : (modelId.split('-')[0] || 'AI').toUpperCase();
                    const roleText = role === 'generated' ? 'GENERATED' : role === 'other' ? document.getElementById('role-other').value.toUpperCase() : role.toUpperCase();
                    badgeHtml = `<span style="display: inline-flex; align-items: center; padding: 4px 12px; background: #2563eb; color: white; font-family: VT323, monospace; font-size: 16px; text-transform: uppercase; border-radius: 4px;">${modelName} ${roleText}</span>`;
                }
            } else if (style === 'glass') {
                const displayRole = role === 'other' ? document.getElementById('role-other').value : role;
                badgeHtml = `<span class="badge-glass badge-glass-primary">AI ${displayRole.toUpperCase()}</span>`;
            } else if (style === 'glass-minimal') {
                const displayRole = role === 'other' ? document.getElementById('role-other').value : role;
                badgeHtml = `<span class="badge-glass-minimal">${displayRole === 'generated' ? 'ai-generated' : 'ai-' + displayRole}</span>`;
            } else if (style === 'terminal') {
                const displayRole = role === 'other' ? document.getElementById('role-other').value : role;
                badgeHtml = `<span class="badge-legacy badge-terminal">AI_${displayRole.toUpperCase()}</span>`;
            } else if (style === 'neon') {
                const displayRole = role === 'other' ? document.getElementById('role-other').value : role;
                badgeHtml = `<span class="badge-legacy badge-neon">AI ${displayRole.toUpperCase()}</span>`;
            } else if (style === 'rainbow') {
                const displayRole = role === 'other' ? document.getElementById('role-other').value : role;
                badgeHtml = `<span class="badge-legacy badge-rainbow">AI ${displayRole.toUpperCase()}</span>`;
            } else if (style === 'matrix') {
                const displayRole = role === 'other' ? document.getElementById('role-other').value : role;
                badgeHtml = `<span class="badge-legacy badge-matrix">AI ${displayRole.toUpperCase()}</span>`;
            } else if (style === 'holographic') {
                const displayRole = role === 'other' ? document.getElementById('role-other').value : role;
                badgeHtml = `<span class="badge-legacy badge-holographic">AI ${displayRole.toUpperCase()}</span>`;
            } else if (style === 'latex') {
                const displayRole = role === 'other' ? document.getElementById('role-other').value : role;
                const roleText = displayRole === 'edited' ? 'AI-ASSISTED' : displayRole.toUpperCase().replace('_', '-');
                badgeHtml = `<div style="font-family: monospace; background: var(--bg-panel); padding: 8px; border: 1px solid var(--border-color); font-size: 12px; color: var(--text-primary);">LaTeX: \\texttt{${roleText}}</div>`;
            }
            
            badgePreview.innerHTML = badgeHtml;
        }
        
        badgeStyleSelect.addEventListener('change', updateBadgePreview);
        document.getElementById('model').addEventListener('change', updateBadgePreview);
        document.getElementById('role').addEventListener('change', updateBadgePreview);
        
        // Initial preview
        setTimeout(updateBadgePreview, 100);
        
        // Update preview when custom role text changes (if element exists)
        const roleOtherInput = document.getElementById('role-other');
        if (roleOtherInput) {
            roleOtherInput.addEventListener('input', updateBadgePreview);
        }

        document.getElementById('model').addEventListener('change', function(e) {
            const otherInput = document.getElementById('model-other');
            const roleSelect = document.getElementById('role');
            
            otherInput.style.display = e.target.value === 'other' ? 'block' : 'none';
            if (e.target.value === 'other') {
                otherInput.required = true;
            } else {
                otherInput.required = false;
                otherInput.value = '';
            }
            
            // Handle Human model selection
            if (e.target.value === 'human') {
                // For human content, set role to "other" and specify "human"
                roleSelect.value = 'other';
                const roleOther = document.getElementById('role-other');
                roleOther.style.display = 'block';
                roleOther.value = 'human';
                roleOther.required = true;
                roleSelect.disabled = true;
            } else {
                // Re-enable role selection for AI models
                roleSelect.disabled = false;
                if (roleSelect.value === 'other' && document.getElementById('role-other').value === 'human') {
                    roleSelect.value = 'generated';
                    document.getElementById('role-other').style.display = 'none';
                    document.getElementById('role-other').value = '';
                }
            }
        });
        
        // Handle custom role selection
        document.getElementById('role').addEventListener('change', function(e) {
            const otherInput = document.getElementById('role-other');
            otherInput.style.display = e.target.value === 'other' ? 'block' : 'none';
            if (e.target.value === 'other') {
                otherInput.required = true;
            } else {
                otherInput.required = false;
                otherInput.value = '';
            }
            updateBadgePreview();
        });

        // Signature method toggle
        document.querySelectorAll('input[name="sign-method"]').forEach(radio => {
            radio.addEventListener('change', function() {
                const walletSection = document.getElementById('wallet-section');
                const localSection = document.getElementById('local-section');
                const hmacSection = document.getElementById('hmac-section');
                
                if (this.value === 'wallet') {
                    walletSection.style.display = 'block';
                    localSection.style.display = 'none';
                    hmacSection.style.display = 'none';
                } else if (this.value === 'local') {
                    walletSection.style.display = 'none';
                    localSection.style.display = 'block';
                    hmacSection.style.display = 'none';
                } else if (this.value === 'hmac') {
                    walletSection.style.display = 'none';
                    localSection.style.display = 'none';
                    hmacSection.style.display = 'block';
                } else {
                    // 'none' option
                    walletSection.style.display = 'none';
                    localSection.style.display = 'none';
                    hmacSection.style.display = 'none';
                }
            });
        });
        
        // Set initial state (local is now default)
        document.getElementById('wallet-section').style.display = 'none';
        document.getElementById('local-section').style.display = 'block';

        // MetaMask integration
        let connectedAccount = null;

        async function connectWallet() {
            const connectBtn = document.getElementById('connect-wallet');
            const buttonText = document.getElementById('wallet-button-text');
            const spinner = document.getElementById('wallet-spinner');
            const statusDiv = document.getElementById('wallet-status');
            
            // Check if already connected and handle disconnect
            if (connectedAccount) {
                connectedAccount = null;
                window.selectedProvider = null;
                statusDiv.style.display = 'none';
                buttonText.textContent = 'Connect Ethereum Wallet';
                connectBtn.style.background = '';
                connectBtn.style.borderColor = '';
                return;
            }
            
            // Check if any ethereum provider exists
            if (typeof window.ethereum === 'undefined') {
                statusDiv.style.display = 'block';
                statusDiv.style.color = 'var(--color-danger)';
                statusDiv.innerHTML = '❌ MetaMask not detected. Please install MetaMask extension.';
                return;
            }

            // Show loading state
            connectBtn.disabled = true;
            buttonText.textContent = 'Connecting...';
            spinner.style.display = 'inline';
            statusDiv.style.display = 'none';

            let provider = window.ethereum;
            
            // Handle multiple providers (MetaMask, Phantom, etc.)
            if (window.ethereum.providers && Array.isArray(window.ethereum.providers)) {
                // Look for MetaMask specifically
                provider = window.ethereum.providers.find((p) => p.isMetaMask);
                
                if (!provider) {
                    // If MetaMask not found, use the first available provider
                    provider = window.ethereum.providers[0];
                    statusDiv.style.display = 'block';
                    statusDiv.style.color = 'var(--color-warning)';
                    statusDiv.innerHTML = '⚠️ Using alternative wallet (MetaMask not found)';
                }
            }

            try {
                // Request accounts with error handling
                const accounts = await provider.request({ method: 'eth_requestAccounts' });
                
                if (accounts && accounts.length > 0) {
                    connectedAccount = accounts[0];
                    // Store the provider for later use
                    window.selectedProvider = provider;
                    
                    // Update UI for success
                    statusDiv.style.display = 'block';
                    statusDiv.style.color = 'var(--color-success)';
                    statusDiv.innerHTML = `✅ Connected: <strong>${connectedAccount.slice(0, 6)}...${connectedAccount.slice(-4)}</strong>`;
                    buttonText.textContent = 'Disconnect Wallet';
                    connectBtn.style.background = '#dc2626';
                    connectBtn.style.borderColor = '#dc2626';
                    connectBtn.disabled = false;
                }
            } catch (error) {
                console.log('Wallet connection error:', error);
                
                // Reset button state
                connectBtn.disabled = false;
                buttonText.textContent = 'Connect Ethereum Wallet';
                spinner.style.display = 'none';
                
                // Show error in status div
                statusDiv.style.display = 'block';
                statusDiv.style.color = 'var(--color-danger)';
                
                if (error.code === 4001) {
                    statusDiv.innerHTML = '❌ Connection rejected. Please try again and accept in MetaMask.';
                } else if (error.code === -32002) {
                    statusDiv.innerHTML = '🔒 Please unlock MetaMask and try again.';
                } else {
                    statusDiv.innerHTML = '❌ Connection failed. Try again or use local signature.';
                }
                return;
            }
            
            // Hide spinner on success
            spinner.style.display = 'none';
        }

        document.getElementById('connect-wallet').addEventListener('click', connectWallet);

        // Remove auto-connection to avoid wallet conflicts
        // Users must manually click to connect their wallet

        // Form submission
        document.getElementById('attestation-form').addEventListener('submit', async function(e) {
            e.preventDefault();
            
            const formData = new FormData(e.target);
            const content = formData.get('content');
            const contentName = formData.get('content_name');
            
            // Calculate content hash if content is provided
            let contentHash = null;
            if (content && content.trim()) {
                const encoder = new TextEncoder();
                const data = encoder.encode(content);
                const hashBuffer = await crypto.subtle.digest('SHA-256', data);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                contentHash = 'sha256:' + hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            }

            // Get document type
            let documentType = formData.get('document_type');
            if (documentType === 'other') {
                documentType = formData.get('document_type_other');
            }

            // Get model
            let model = formData.get('model');
            if (model === 'other') {
                model = formData.get('model_other');
            }

            // Get role
            let role = formData.get('role');
            if (role === 'other') {
                role = formData.get('role_other');
            }
            
            // Build attestation
            const attestation = {
                version: "2.0",
                id: new Date().toISOString().split('T')[0] + '-' + Math.random().toString(36).substring(2, 8),
                content_name: contentName,
                document_type: documentType,
                model: model,
                role: role,
                timestamp: new Date().toISOString(),
                platform: "attest.ink",
                badge_style: formData.get('badge_style') || 'default'
            };
            
            // Add content hash only if content was provided
            if (contentHash) {
                attestation.content_hash = contentHash;
            }

            // Add optional fields
            const author = formData.get('author');
            if (author) attestation.author = author;

            const prompt = formData.get('prompt');
            if (prompt) {
                if (formData.get('prompt_private')) {
                    // Hash the prompt
                    const promptData = encoder.encode(prompt);
                    const promptHashBuffer = await crypto.subtle.digest('SHA-256', promptData);
                    const promptHashArray = Array.from(new Uint8Array(promptHashBuffer));
                    attestation.prompt_hash = 'sha256:' + promptHashArray.map(b => b.toString(16).padStart(2, '0')).join('');
                } else {
                    attestation.prompt = prompt;
                }
            }

            // Sign based on selected method
            const signMethod = document.querySelector('input[name="sign-method"]:checked').value;
            
            if (signMethod === 'wallet') {
                if (!connectedAccount) {
                    alert('Please connect your Ethereum wallet first by clicking "Connect Ethereum Wallet"');
                    return;
                }
                try {
                    // Create message to sign (include content_name for v2.0)
                    const messageData = {
                        content_name: attestation.content_name,
                        model: attestation.model,
                        timestamp: attestation.timestamp
                    };
                    // Only include content_hash if it exists
                    if (attestation.content_hash) {
                        messageData.content_hash = attestation.content_hash;
                    }
                    const message = JSON.stringify(messageData);

                    // Use the selected provider (MetaMask or other)
                    const provider = window.selectedProvider || window.ethereum;
                    
                    // Request signature
                    const signature = await provider.request({
                        method: 'personal_sign',
                        params: [message, connectedAccount]
                    });

                    attestation.signature = {
                        type: 'ethereum',
                        value: signature,
                        signer: connectedAccount,
                        message: message
                    };
                } catch (error) {
                    console.error('Signing failed:', error);
                    if (error.code === 4001) {
                        alert('Signing rejected. Please approve the signature request in your wallet.');
                        return;
                    } else if (!confirm('Signing failed. Continue without signature?')) {
                        return;
                    }
                }
            } else if (signMethod === 'none') {
                // No signature requested - skip signing
            } else if (signMethod === 'hmac') {
                // HMAC-SHA256 signature
                const signerName = document.getElementById('signer-name').value;
                const signerId = document.getElementById('signer-id').value;
                
                if (!signerName) {
                    alert('Please enter the signer name for HMAC signature');
                    return;
                }
                
                // For HMAC, we prepare the attestation with signer info
                // The actual signing needs to be done server-side
                attestation.signer = {
                    name: signerName
                };
                if (signerId) {
                    attestation.signer.id = signerId;
                }
                
                // Create the data structure that would be signed
                const dataToSign = JSON.stringify({
                    content_name: attestation.content_name,
                    content_hash: attestation.content_hash,
                    timestamp: attestation.timestamp,
                    model: attestation.model
                });
                
                // Since we can't sign client-side with HMAC (no private key),
                // we'll create a placeholder signature structure
                attestation.signature = {
                    type: 'hmac-sha256',
                    value: 'UNSIGNED_HMAC_PLACEHOLDER',
                    algorithm: 'HMAC-SHA256',
                    data_to_sign: dataToSign,
                    note: 'This attestation requires server-side signing with your private key'
                };
                
                // Add generation_type field based on model
                if (attestation.model === 'human') {
                    attestation.generation_type = 'human';
                } else {
                    attestation.generation_type = 'ai';
                }
            } else if (signMethod === 'local') {
                const password = document.getElementById('signing-password').value;
                if (!password) {
                    alert('Please enter a password for signing');
                    return;
                }
                
                try {
                    // Create message to sign
                    const message = JSON.stringify({
                        content_hash: attestation.content_hash,
                        model: attestation.model,
                        timestamp: attestation.timestamp
                    });
                    
                    // Generate key from password
                    const enc = new TextEncoder();
                    const keyMaterial = await crypto.subtle.importKey(
                        'raw',
                        enc.encode(password),
                        'PBKDF2',
                        false,
                        ['deriveBits', 'deriveKey']
                    );
                    
                    // Derive signing key
                    const salt = enc.encode('attest.ink.v1.' + attestation.id);
                    const key = await crypto.subtle.deriveKey(
                        {
                            name: 'PBKDF2',
                            salt: salt,
                            iterations: 100000,
                            hash: 'SHA-256'
                        },
                        keyMaterial,
                        { name: 'HMAC', hash: 'SHA-256', length: 256 },
                        false,
                        ['sign']
                    );
                    
                    // Sign the message
                    const signature = await crypto.subtle.sign(
                        'HMAC',
                        key,
                        enc.encode(message)
                    );
                    
                    // Convert to hex
                    const sigArray = Array.from(new Uint8Array(signature));
                    const sigHex = sigArray.map(b => b.toString(16).padStart(2, '0')).join('');
                    
                    // Create signer ID from password (hash it)
                    const signerData = enc.encode('attest.ink.signer.' + password);
                    const signerHash = await crypto.subtle.digest('SHA-256', signerData);
                    const signerArray = Array.from(new Uint8Array(signerHash));
                    const signerId = '0x' + signerArray.slice(0, 20).map(b => b.toString(16).padStart(2, '0')).join('');
                    
                    attestation.signature = {
                        type: 'local',
                        value: '0x' + sigHex,
                        signer: signerId,
                        message: message,
                        algorithm: 'HMAC-SHA256-PBKDF2'
                    };
                } catch (error) {
                    console.error('Local signing failed:', error);
                    alert('Failed to create signature. Please try again.');
                    return;
                }
            }

            // Store in localStorage before redirecting
            try {
                localStorage.setItem(`attestation-${attestation.id}`, JSON.stringify(attestation));
                
                // Clear the form changes flag since attestation was successfully created
                formHasChanges = false;
                
                // Redirect to result page
                window.location.href = `/attestation-result.html?id=${attestation.id}`;
            } catch (e) {
                console.error('Failed to store attestation in localStorage:', e);
                alert('Failed to save attestation. Please try again.');
                return;
            }
        });

        // Reset form button handler
        document.getElementById('reset-form').addEventListener('click', function() {
            if (confirm('Are you sure you want to reset the form? All entered data will be lost.')) {
                // Reset the form
                document.getElementById('attestation-form').reset();
                
                // Reset custom inputs visibility
                document.getElementById('model-other').style.display = 'none';
                document.getElementById('model-other').required = false;
                document.getElementById('role-other').style.display = 'none';
                document.getElementById('role-other').required = false;
                document.getElementById('document-type-other').style.display = 'none';
                document.getElementById('document-type-other').required = false;
                
                // Reset signature method sections
                document.querySelectorAll('input[name="sign-method"]')[0].checked = true; // Set to "local"
                document.getElementById('wallet-section').style.display = 'none';
                document.getElementById('local-section').style.display = 'block';
                document.getElementById('hmac-section').style.display = 'none';
                
                // Clear wallet connection if any
                if (window.connectedAccount) {
                    window.connectedAccount = null;
                    document.getElementById('wallet-address').textContent = '';
                    document.getElementById('wallet-info').style.display = 'none';
                    document.getElementById('wallet-button-text').textContent = 'Connect Ethereum Wallet';
                    document.getElementById('disconnect-wallet').style.display = 'none';
                }
                
                // Clear password fields
                document.getElementById('signing-password').value = '';
                document.getElementById('signer-name').value = '';
                document.getElementById('signer-id').value = '';
                
                // Reset badge preview
                updateBadgePreview();
                
                // Reset form changes tracking
                formHasChanges = false;
                
                // Scroll to top
                window.scrollTo(0, 0);
            }
        });
    </script>
    <script src="/static/theme.js"></script>
    <script src="/static/global-footer.js"></script>
</body>
</html>